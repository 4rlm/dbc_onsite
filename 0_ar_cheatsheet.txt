########################################################

#### Active Record CheatSheet ####
Naming Convention:
Class names singular, capitalized, CamelCase
Table names plural, lower_case, snake_case

User / Users
LineItem / line_items
Deer / deer
Person / people

Foreign key names singular, snake_case
User / user_id
LineItem / line_item_id
Deer / deer_id
Person / person_id

################################

ActiveRecord:
* Creates Tables
* Maps ruby classes to db tables
* Associations between classes
* Validations

################################

Write classes that inherit from AR module, ex:

module ActiveRecord
  class Migration
    #
  end

  class Base
    #
  end

  #...

end

################################
Build database schema by writing migrations:

class CreateOrange < ActiveRecord::Migration
  def change
    # what we want to do with the db...
  end
end

################################
Mapping Classes to Tables: Modeling State

Ruby / DB
Classes / Tables
Instances of Classes / Rows
Instance Variables / Fields

* Class methods to retrieve records from table.
* Instance methods to read and write values.


################################
Associations between Classes:

orange_trees / oranges
id / orange_tree_id

* Orange belongs to Orange Tree
* Orange gets the foreign_key (orange_tree_id)

#### Define Associations between Classes (in Model):

class OrangeTree < ActiveRecord::Base
  has_many :oranges
  has_many :seeds, through: :oranges
end

class Orange < ActiveRecord::Base
  belongs_to :orange_tree
  has_many :seeds
end

class Seed < ActiveRecord::Base
  belongs_to :orange
end

table oranges has orange_tree_id (foreign_key)
table seeds has orange_id (foreign_key)

################################
Unconventional Associations:

######## Wrong ID ########
class OrangeTree < ActiveRecord::Base
  has_many :oranges, { foreign_key :tree_id }
end

class Orange < ActiveRecord::Base
  belongs_to :orange_tree, { foreign_key :tree_id }
end

######## Wrong Class Name ########
class OrangeTree < ActiveRecord::Base
  has_many :fruits, { class_name: "Orange" }
end

class Orange < ActiveRecord::Base
  belongs_to :tree, { class_name: "OrangeTree" }
end






#### Instance Methods to retrieve, update, delete, create, etc. associated objects.

################################
Validations:  Built-in and Custom

class Orange < ActiveRecord::Base
  validate :legit_diameter

  def legit_diameter
    # Add errors here ...
  end

end





1) Generate Model & Table
bundle exec rake generate:model NAME=Person
bundle exec rake generate:migration NAME=create_people
class CreatePeople < ActiveRecord::Migration[5.0]
  def change
    create_table :people do |t|
      t.string  :first_name, {nul: false, limit: 50}
      t.string  :last_name, {nul: false, limit: 50}

      t.timestamps
    end
  end
end

2) remove_column
bundle exec rake generate:migration NAME=remove_weight_from_dogs
class RemoveWeightFromDogs < ActiveRecord::Migration[5.0]
  def change
    remove_column :dogs, :weight
  end
end

3) add_column
bundle exec rake generate:migration NAME=add_breed_to_dogs
class AddBreedToDogs < ActiveRecord::Migration[5.0]
  def change
    add_column :dogs, :breed, :string
  end
end

4) rename_column
bundle exec rake generate:migration NAME=rename_rater_id_to_judge_id_on_ratings
class RenameRaterIdToJudgeIdOnRatings < ActiveRecord::Migration[5.0]
  def change
    rename_column :ratings, :rater_id, :judge_id
  end
end

5) Query
Dog.where(age: 1)
Dog.where("age = ? and name like ?", 1, '%Te%')
Dog.order(age: :desc)
Dog.limit(2)
Dog.count
Dog.pluck(:name, :age)
Dog.first
Dog.find_by(name: "Jayda")
Dog.order(name: :asc).where(age: 1).limit(1)

6) Inserting & Updating
new_dog = Dog.new(name: "Bear") #=> memory only
Dog.new(color: "brown")
Dog.count
new_dog.persisted?
new_dog.save
Dog.create(name: "Max") #=> create and save one
Dog.create [{name: "Toot"}, {name: "Cosmo"}] #=> create and save multiple
Dog.find_or_create_by(name: "Taj", license: "OH-9084736")
tenley = Dog.find_by(name: "Tenley")
tenley.assign_attributes(age: 3, license: "OH-1234567")
rabid_dog = Dog.create(name: "Old Yeller", age: 5, breed: "Black Mouth Cur")
rabid_dog.destroy
Rating.where("judge_id = 1 AND dog_id = 2").update_all(cuteness: 7)
Rating.where(judge_id: 5).destroy_all
Rating.where("dog_id = 1 AND cuteness < 10").update_all(cuteness: 10)
Rating.where("dog_id = 3 AND coolness = 7 AND cuteness = 4 AND judge_id = 4").update_all(judge_id: 6)
Rating.where("dog_id = 2 AND judge_id = 2 AND coolness = 10 AND cuteness = 8").update_all("coolness = 8 AND cuteness = 10")

7) Validations
belongs_to :owner, { class_name: "Person" }
validates :owner, { :presence => true }
validates :name, :license, { :presence => true }
validates :license, { :uniqueness => true }

validates :license, format: { with: /\A[A-Z]{2}\-/ }
validates :age, { :numericality => { greater_than_or_equal_to: 0 },
                  :allow_blank  => true }

validate :license_from_valid_state
def license_from_valid_state
  unless self.license.instance_of? String
    errors.add :license, "must be a string"
    return
  end

  abbreviation = self.license[0..1]
  unless valid_state_abbreviation? abbreviation
    errors.add :license, "must be from a valid US state"
  end
end
